这是一套经过我们反复讨论、优化后的**完整工程化代码**。

这就好比我们为你量身定制了一套“Ant Design 表单自动化测试框架”。它包含了：

1. **接口层**：定义标准行为。
2. **配置层**：基于 Selector 的极简规则库。
3. **组件层**：封装 AntD 的具体交互（特别是难搞的 Select）。
4. **核心层**：智能表单对象，包含 `scanFields` 扫描引擎。
5. **测试层**：实际调用的例子。

你可以直接将这些代码复制到你的 Playwright 项目中对应的文件夹下。

### 1. 目录结构建议

```text
tests/
  ├── components/
  │   ├── widgets/
  │   │   ├── interface.ts        # 统一接口
  │   │   ├── rules.ts            # 扫描规则配置
  │   │   ├── antd-input.ts       # 具体组件实现
  │   │   ├── antd-select.ts
  │   │   ├── antd-checkbox.ts
  │   │   ├── antd-datepicker.ts  # 新增 DatePicker 支持
  │   │   └── index.ts            # 组件映射表
  │   └── antd-form.ts            # 核心表单类
  └── example.spec.ts             # 测试用例
```

---

### 2. 核心代码实现

#### `components/widgets/interface.ts` (定义接口)

```typescript
import { Locator } from '@playwright/test';

export interface FormWidget<T = any> {
  /** 核心方法：设置组件的值 */
  setValue(value: T): Promise<void>;
  
  /** 核心方法：获取组件的值（用于断言） */
  getValue(): Promise<T>;
  
  /** 暴露底层 Locator 以便进行特殊操作（如 hover, dblclick） */
  getLocator(): Locator;
}
```

#### `components/widgets/rules.ts` (配置规则)

这里采用了我们讨论过的**“顺序优先 + Selector 查找”**策略。

```typescript
export type WidgetType = 'Select' | 'DatePicker' | 'Checkbox' | 'Button' | 'Input' | 'Default';

export interface DetectionRule {
  type: WidgetType;
  selector: string; // 在 control 内部查找这个选择器
}

// 规则列表：越复杂的组件越靠前，简单的 Input 兜底
export const ANT_DESIGN_RULES: DetectionRule[] = [
  // 1. 复杂/嵌套组件
  { type: 'Select',     selector: '.ant-select' },
  { type: 'DatePicker', selector: '.ant-picker' },
  { type: 'Checkbox',   selector: '.ant-checkbox-wrapper' },

  // 2. 基础组件 (Input 必须放在 Select 后面，因为 Select 内部也有 input)
  { type: 'Input',      selector: 'input.ant-input' }, 
  
  // 3. 兜底 (可选)
  // { type: 'Input', selector: 'input' } 
];
```

#### `components/widgets/antd-input.ts` (Input 实现)

```typescript
import { Locator } from '@playwright/test';
import { FormWidget } from './interface';

export class AntdInput implements FormWidget<string> {
  constructor(private root: Locator) {}

  async setValue(value: string) {
    // 查找 control 区域内的 input 标签
    await this.root.locator('input').fill(value);
  }

  async getValue() {
    return await this.root.locator('input').inputValue();
  }

  getLocator() { return this.root; }
}
```

#### `components/widgets/antd-select.ts` (Select 实现 - 难点)

AntD 的下拉菜单渲染在 body 根节点，不在 Form 内部，需要特殊处理。

```typescript
import { Locator } from '@playwright/test';
import { FormWidget } from './interface';

export class AntdSelect implements FormWidget<string> {
  constructor(private root: Locator) {}

  async setValue(value: string) {
    // 1. 点击触发器 (Trigger)
    // 尝试点击 .ant-select-selector，如果不存在则点击 .ant-select
    const trigger = this.root.locator('.ant-select-selector').or(this.root.locator('.ant-select'));
    await trigger.first().click();

    // 2. 在 Body 中寻找下拉菜单 (Dropdown)
    const page = this.root.page();
    const dropdown = page.locator('.ant-select-dropdown:not(.ant-select-dropdown-hidden)');
    
    // 3. 选中对应的 Option
    // 使用 exact: true 避免 "Male" 匹配到 "Female"
    // 允许前后空格
    const option = dropdown.locator('.ant-select-item-option').filter({ hasText: new RegExp(`^\\s*${value}\\s*$`) });
    
    // Debug info if not found
    if (await option.count() === 0) {
       console.log(`Warning: Option "${value}" not found. Available:`, await dropdown.locator('.ant-select-item-option').allInnerTexts());
    }
    
    await option.first().click();
  }

  async getValue() {
    // 获取选中的文本
    // 尝试多种可能的类名 (AntD 版本差异)
    const item = this.root.locator('.ant-select-selection-item').or(this.root.locator('.ant-select-content-value'));
    return await item.innerText();
  }

  getLocator() { return this.root; }
}
```

#### `components/widgets/antd-checkbox.ts` (Checkbox 实现)

```typescript
import { Locator } from '@playwright/test';
import { FormWidget } from './interface';

export class AntdCheckbox implements FormWidget<boolean> {
  constructor(private root: Locator) {}

  async setValue(checked: boolean) {
    // AntD Checkbox 的 input 是隐藏的，建议操作外层的 wrapper label
    const wrapper = this.root.locator('.ant-checkbox-wrapper');
    if (checked) {
      await wrapper.check();
    } else {
      await wrapper.uncheck();
    }
  }

  async getValue() {
    return await this.root.locator('input[type="checkbox"]').isChecked();
  }

  getLocator() { return this.root; }
}
```

#### `components/widgets/antd-datepicker.ts` (DatePicker 实现)

```typescript
import { Locator } from '@playwright/test';
import { FormWidget } from './interface';

export class AntdDatePicker implements FormWidget<string> {
  constructor(private root: Locator) {}

  async setValue(value: string) {
    const input = this.root.locator('input');
    await input.click(); // Focus first
    await input.fill(value);
    await input.press('Enter'); // Confirm date and close popup
  }

  async getValue() {
    return await this.root.locator('input').inputValue();
  }

  getLocator() { return this.root; }
}
```

#### `components/widgets/index.ts` (组件注册表)

```typescript
import { Locator } from '@playwright/test';
import { FormWidget } from './interface';
import { WidgetType } from './rules';

import { AntdInput } from './antd-input';
import { AntdSelect } from './antd-select';
import { AntdCheckbox } from './antd-checkbox';
import { AntdDatePicker } from './antd-datepicker';

// 构造函数类型定义
type WidgetConstructor = new (root: Locator) => FormWidget;

// 核心映射表：字符串 -> 类
export const WIDGET_MAP: Record<WidgetType, WidgetConstructor> = {
  'Input': AntdInput,
  'Select': AntdSelect,
  'Checkbox': AntdCheckbox,
  'DatePicker': AntdDatePicker,
  'Button': AntdInput,     // 占位
  'Default': AntdInput
};
```

---

#### `components/antd-form.ts` (智能表单对象 - 核心)

包含我们讨论的 `scanFields` 引擎、多级 Label 策略和 Selector 匹配。

```typescript
import { Page, Locator } from '@playwright/test';
import { FormWidget } from './widgets/interface';
import { ANT_DESIGN_RULES } from './widgets/rules';
import { WIDGET_MAP, WidgetType } from './widgets/index';

export class AntdForm {
  readonly page: Page;
  readonly root: Locator;
  
  // 缓存：Label -> 组件类型
  private schema: Map<string, WidgetType> = new Map();

  constructor(page: Page, rootSelector = 'form.ant-form') {
    this.page = page;
    this.root = page.locator(rootSelector);
  }

  /**
   * 静态工厂方法，自动创建并扫描表单
   */
  static async create(page: Page, rootSelector = 'form.ant-form'): Promise<AntdForm> {
    const form = new AntdForm(page, rootSelector);
    await form.scanFields();
    return form;
  }

  /**
   * 核心引擎：在浏览器上下文中扫描表单结构
   */
  async scanFields() {
    await this.root.waitFor(); 

    // 1. 注入规则，并在浏览器内执行分析
    const detectedFields = await this.root.evaluate((formElement, rules) => {
      const results: { label: string; type: string }[] = [];
      const items = formElement.querySelectorAll('.ant-form-item');

      items.forEach(item => {
        const controlNode = item.querySelector('.ant-form-item-control');
        
        // --- 卫语句：防止处理幽灵节点 ---
        if (!controlNode) return; 

        // --- 策略：多级 Label 解析 ---
        let label = '';
        // 1. 找标准 Label
        const labelNode = item.querySelector('.ant-form-item-label label');
        if (labelNode) {
          label = labelNode.textContent?.trim() || '';
        }
        // 2. 找控件内文本 (针对 Checkbox/Button)
        if (!label) {
            const text = (controlNode as HTMLElement).innerText?.trim();
            if (text && text.length < 30) label = text;
        }
        // 3. 找 Placeholder (针对无 Label 输入框)
        if (!label) {
            const input = controlNode.querySelector('input');
            if (input && input.placeholder) label = input.placeholder;
        }

        if (!label) return; // 实在找不到名字，跳过

        // --- 策略：基于 Selector 的类型推导 ---
        let detectedType = 'Default';
        
        for (const rule of rules) {
          // 直接在 control 内部查找子孙，命中即止
          if (controlNode.querySelector(rule.selector)) {
            detectedType = rule.type;
            break; 
          }
        }

        results.push({ label, type: detectedType });
      });

      return results;
    }, ANT_DESIGN_RULES);

    // 2. 更新本地映射表
    this.schema.clear();
    for (const field of detectedFields) {
      this.schema.set(field.label, field.type as WidgetType);
    }
    
    // 调试用：打印扫描结果
    console.log('Form Schema Detected:', Object.fromEntries(this.schema));
  }

  /**
   * 获取组件实例
   */
  field<T extends FormWidget = FormWidget>(labelText: string): T {
    // 1. 查表
    const type = this.schema.get(labelText);
    if (!type) {
      throw new Error(`Field "${labelText}" not found in schema. Did you forget to call scanFields()?`);
    }

    // 2. 实例化
    const WidgetClass = WIDGET_MAP[type] || WIDGET_MAP['Default'];
    
    // 3. 定位到具体的 control 区域 (Playwright 懒加载)
    const controlArea = this.root
      .locator('.ant-form-item', { hasText: labelText }) // 这里的 hasText 很宽松，也能匹配到 placeholder
      .locator('.ant-form-item-control');

    return new WidgetClass(controlArea) as T;
  }

  /**
   * 获取按钮组件
   */
  button(name: string): Locator {
    return this.root.getByRole('button', { name });
  }
}
```

---

### 3. 测试用例

#### `tests/demo.spec.ts`

```typescript
import { test, expect } from '@playwright/test';
import { AntdForm } from '../components/antd-form';

test('Ant Design Form Automation Demo', async ({ page }) => {
  await page.goto('/');

  // 1. Initialize and scan the form
  const form = await AntdForm.create(page);

  // 2. Interact with widgets
  await form.field('Username').setValue('testuser');
  await form.field('Gender').setValue('Male'); 
  await form.field('Agreement').setValue(true);
  await form.field('Birth Date').setValue('2023-01-01');

  // 3. Verify values
  expect(await form.field('Username').getValue()).toBe('testuser');
  expect(await form.field('Gender').getValue()).toBe('Male');
  expect(await form.field('Agreement').getValue()).toBe(true);
  expect(await form.field('Birth Date').getValue()).toBe('2023-01-01');

  // 4. Submit
  await form.button('Submit').click();
});
```


### 代码亮点总结

1. **极简配置**：在 `rules.ts` 里，你只需要像写 CSS 一样加一行 `{ type: 'MyComponent', selector: '.my-class' }`，系统就能自动识别新组件。
2. **双重容错**：
* **类型容错**：`scanFields` 用 JS 原生 API 快速试错。
* **Label 容错**：找不到 Label 找文字，找不到文字找 Placeholder，模拟人类视觉。


3. **高性能**：所有的 DOM 分析都在 `page.evaluate` 的一次往返中完成，测试运行速度极快。
